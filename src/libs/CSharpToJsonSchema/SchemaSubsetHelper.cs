using System.Text.Json.Nodes;
using System.Text.Json.Schema;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;

namespace CSharpToJsonSchema;

public static class SchemaBuilder
{
    /// <summary>
    /// Converts a JSON document that contains valid json schema <see href="https://json-schema.org/specification"/> as e.g. 
    /// generated by <code>Microsoft.Extensions.AI.AIJsonUtilities.CreateJsonSchema</code> or <code>JsonSchema.Net</code>'s
    /// <see cref="JsonSchemaBuilder"/> to a subset that is compatible with LLM's APIs.
    /// </summary>
    /// <param name="constructedSchema">Generated, valid json schema.</param>
    /// <returns>Subset of the given json schema in a LLM-compatible format.</returns>
    public static OpenApiSchema ConvertToCompatibleSchemaSubset(JsonNode node)
    {
        ConvertNullableProperties(node);
        var x1 = node;
        var x2 = x1.ToJsonString();
        var schema = JsonSerializer.Deserialize(x2, OpenApiSchemaJsonContext.Default.OpenApiSchema);
        return schema;
    }

    private static void ConvertNullableProperties(JsonNode? node)
    {
        // If the node is an object, look for a "type" property or nested definitions
        if (node is JsonObject obj)
        {
            // If "type" is an array, remove "null" and collapse if it leaves only one type
            if (obj.TryGetPropertyValue("type", out var typeValue) && typeValue is JsonArray array)
            {
                if (array.Count == 2)
                {
                    var notNullTypes = array.Where(x => x is not null && x.GetValue<string>() != "null").ToList();
                    if (notNullTypes.Count == 1)
                    {
                        obj["type"] = notNullTypes[0]!.GetValue<string>();
                        obj["nullable"] = true;
                    }
                    else
                    {
                        throw new InvalidOperationException(
                            $"LLM's API for strucutured output requires every property to have one defined type, not multiple options. Path: {obj.GetPath()} Schema: {obj.ToJsonString()}");
                    }
                }
                else if (array.Count > 2)
                {
                    throw new InvalidOperationException(
                        $"LLM's API for strucutured output requires every property to have one defined type, not multiple options. Path: {obj.GetPath()} Schema: {obj.ToJsonString()}");
                }
            }

            // Recursively convert any nested schema in "properties"
            if (obj.TryGetPropertyValue("properties", out var propertiesNode) &&
                propertiesNode is JsonObject propertiesObj)
            {
                foreach (var property in propertiesObj)
                {
                    ConvertNullableProperties(property.Value);
                }
            }

            if (obj.TryGetPropertyValue("type", out var newTypeValue)
                && newTypeValue is JsonNode
                && newTypeValue.GetValueKind() == JsonValueKind.String
                && "object".Equals(newTypeValue.GetValue<string>(), StringComparison.OrdinalIgnoreCase)
                && propertiesNode is not JsonObject)
            {
                throw new InvalidOperationException(
                    $"LLM's API for strucutured output requires every object to have predefined properties. Notably, it does not support dictionaries. Path: {obj.GetPath()} Schema: {obj.ToJsonString()}");
            }

            // Recursively convert any nested schema in "items"
            if (obj.TryGetPropertyValue("items", out var itemsNode))
            {
                ConvertNullableProperties(itemsNode);
            }
        }

        // If the node is an array, traverse each element
        if (node is JsonArray arr)
        {
            foreach (var element in arr)
            {
                ConvertNullableProperties(element);
            }
        }
    }

    public static OpenApiSchema ConvertToSchema<T>(JsonSerializerOptions? jsonOptions = null)
    {
        if (jsonOptions == null && !JsonSerializer.IsReflectionEnabledByDefault)
        {
            throw new InvalidOperationException("Please provide a JsonSerializerOptions instance to use in AOT mode.");
        }


        var newJsonOptions = new JsonSerializerOptions(jsonOptions)
        {
            NumberHandling = JsonNumberHandling.Strict
        };

        var typeInfo = newJsonOptions.GetTypeInfo(typeof(T));

        return ConvertToCompatibleSchemaSubset(typeInfo.GetJsonSchemaAsNode());
    }

    public static OpenApiSchema ConvertToSchema(JsonTypeInfo type, string descriptionString)
    {
        var typeInfo = type;

        var dics = JsonSerializer.Deserialize(descriptionString,
            OpenApiSchemaJsonContext.Default.IDictionaryStringString);
        List<string> required = new List<string>();
        var x = ConvertToCompatibleSchemaSubset(typeInfo.GetJsonSchemaAsNode(
            exporterOptions: new JsonSchemaExporterOptions()
            {
                TransformSchemaNode = (a, b) =>
                {
                    if (a.TypeInfo.Type.IsEnum)
                    {
                        b["type"] = "string";
                    }

                    if (a.PropertyInfo == null)
                        return b;
                    var propName = ToCamelCase(a.PropertyInfo.Name);
                    if (dics.ContainsKey(propName))
                    {
                        b["description"] = dics[propName];
                    }

                    return b;
                },
            }));


        foreach (var re in x.Properties)
        {
            required.Add(re.Key);
        }
       
        var mainDescription = x.Description ?? (dics.TryGetValue("mainFunction_Desc", out var desc) ? desc : "");
        return new OpenApiSchema()
        {
            Description = mainDescription,
            Properties = x.Properties,
            Required = required,
            Type = "object"
        };
    }

    public static string ToCamelCase(string str)
    {
        if (!string.IsNullOrEmpty(str) && str.Length > 1)
        {
            return char.ToLowerInvariant(str[0]) + str.Substring(1);
        }

        return str.ToLowerInvariant();
    }

    public static string ConvertToSchema(Type type, JsonSerializerOptions? jsonOptions)
    {
        var node = jsonOptions.GetJsonSchemaAsNode(type);
        var x = ConvertToCompatibleSchemaSubset(node);

        return JsonSerializer.Serialize(x.Properties, OpenApiSchemaJsonContext.Default.IDictionaryStringOpenApiSchema);
    }
}